import { arrow as j, computePosition as A } from "../../../../../@floating-ui_dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.js";
import { autoUpdate as W, flip as X, offset as Y, platform as Z } from "../../../../../@floating-ui_dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.js";
import { isNode as B, getNodeName as F } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.js";
import { getOverflowAncestors as ne } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.js";
import { computed as r, ref as c, shallowRef as I, watch as x, getCurrentScope as U, onScopeDispose as k, shallowReadonly as o, unref as q } from "vue";
function z(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function V(e) {
  if (z(e)) {
    const l = e.$el;
    return B(l) && F(l) === "#comment" ? null : l;
  }
  return e;
}
function i(e) {
  return typeof e == "function" ? e() : q(e);
}
function K(e) {
  return {
    name: "arrow",
    options: e,
    fn(l) {
      const t = V(i(e.element));
      return t == null ? {} : j({
        element: t,
        padding: e.padding
      }).fn(l);
    }
  };
}
function M(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function C(e, l) {
  const t = M(e);
  return Math.round(l * t) / t;
}
function L(e, l, t) {
  t === void 0 && (t = {});
  const D = t.whileElementsMounted, s = r(() => {
    var n;
    return (n = i(t.open)) != null ? n : !0;
  }), O = r(() => i(t.middleware)), p = r(() => {
    var n;
    return (n = i(t.placement)) != null ? n : "bottom";
  }), w = r(() => {
    var n;
    return (n = i(t.strategy)) != null ? n : "absolute";
  }), S = r(() => {
    var n;
    return (n = i(t.transform)) != null ? n : !0;
  }), f = r(() => V(e.value)), u = r(() => V(l.value)), y = c(0), h = c(0), m = c(w.value), P = c(p.value), E = I({}), g = c(!1), _ = r(() => {
    const n = {
      position: m.value,
      left: "0",
      top: "0"
    };
    if (!u.value)
      return n;
    const a = C(u.value, y.value), b = C(u.value, h.value);
    return S.value ? {
      ...n,
      transform: "translate(" + a + "px, " + b + "px)",
      ...M(u.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: m.value,
      left: a + "px",
      top: b + "px"
    };
  });
  let d;
  function v() {
    if (f.value == null || u.value == null)
      return;
    const n = s.value;
    A(f.value, u.value, {
      middleware: O.value,
      placement: p.value,
      strategy: w.value
    }).then((a) => {
      y.value = a.x, h.value = a.y, m.value = a.strategy, P.value = a.placement, E.value = a.middlewareData, g.value = n !== !1;
    });
  }
  function R() {
    typeof d == "function" && (d(), d = void 0);
  }
  function N() {
    if (R(), D === void 0) {
      v();
      return;
    }
    if (f.value != null && u.value != null) {
      d = D(f.value, u.value, v);
      return;
    }
  }
  function $() {
    s.value || (g.value = !1);
  }
  return x([O, p, w, s], v, {
    flush: "sync"
  }), x([f, u], N, {
    flush: "sync"
  }), x(s, $, {
    flush: "sync"
  }), U() && k(R), {
    x: o(y),
    y: o(h),
    strategy: o(m),
    placement: o(P),
    middlewareData: o(E),
    isPositioned: o(g),
    floatingStyles: _,
    update: v
  };
}
export {
  K as arrow,
  W as autoUpdate,
  A as computePosition,
  X as flip,
  ne as getOverflowAncestors,
  Y as offset,
  Z as platform,
  L as useFloating
};
