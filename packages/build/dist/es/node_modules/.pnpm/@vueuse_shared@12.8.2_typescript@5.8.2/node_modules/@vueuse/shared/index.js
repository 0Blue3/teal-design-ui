import { getCurrentScope as f, onScopeDispose as p, watch as d, shallowRef as m, readonly as y, onMounted as g, nextTick as S, toValue as b, getCurrentInstance as w } from "vue";
function T(e) {
  return f() ? (p(e), !0) : !1;
}
const C = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const O = Object.prototype.toString, k = (e) => O.call(e) === "[object Object]";
function v(e) {
  let t;
  function n() {
    return t || (t = e()), t;
  }
  return n.reset = async () => {
    const o = t;
    t = void 0, o && await o;
  }, n;
}
function h(e) {
  return w();
}
function A(e) {
  return Array.isArray(e) ? e : [e];
}
function P(e, t = !0, n) {
  h() ? g(e, n) : t ? e() : S(e);
}
function x(e, t, n = {}) {
  const {
    immediate: o = !0,
    immediateCallback: s = !1
  } = n, i = m(!1);
  let r = null;
  function u() {
    r && (clearTimeout(r), r = null);
  }
  function c() {
    i.value = !1, u();
  }
  function a(...l) {
    s && e(), u(), i.value = !0, r = setTimeout(() => {
      i.value = !1, r = null, e(...l);
    }, b(t));
  }
  return o && (i.value = !0, C && a()), T(c), {
    isPending: y(i),
    start: a,
    stop: c
  };
}
function D(e, t, n) {
  return d(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
export {
  v as createSingletonPromise,
  h as getLifeCycleTarget,
  C as isClient,
  k as isObject,
  A as toArray,
  P as tryOnMounted,
  T as tryOnScopeDispose,
  x as useTimeoutFn,
  D as watchImmediate
};
