import { offset as ot, flip as st, arrow as rt, computePosition as ct } from "../../../../../@floating-ui_core@1.6.9/node_modules/@floating-ui/core/dist/floating-ui.core.js";
import { createCoords as m, rectToClientRect as J, floor as A, max as E, round as H, min as z } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
import { getOverflowAncestors as M, isElement as v, getDocumentElement as O, getWindow as L, getFrameElement as K, getComputedStyle as R, isHTMLElement as b, isWebKit as Q, isTopLayer as $, getParentNode as W, isLastTraversableNode as N, isTableElement as lt, isContainingBlock as Y, getContainingBlock as ft, getNodeName as S, isOverflowElement as _, getNodeScroll as I } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.js";
function Z(t) {
  const e = R(t);
  let n = parseFloat(e.width) || 0, i = parseFloat(e.height) || 0;
  const o = b(t), r = o ? t.offsetWidth : n, s = o ? t.offsetHeight : i, c = H(n) !== r || H(i) !== s;
  return c && (n = r, i = s), {
    width: n,
    height: i,
    $: c
  };
}
function q(t) {
  return v(t) ? t : t.contextElement;
}
function F(t) {
  const e = q(t);
  if (!b(e))
    return m(1);
  const n = e.getBoundingClientRect(), {
    width: i,
    height: o,
    $: r
  } = Z(e);
  let s = (r ? H(n.width) : n.width) / i, c = (r ? H(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const ut = /* @__PURE__ */ m(0);
function X(t) {
  const e = L(t);
  return !Q() || !e.visualViewport ? ut : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ht(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== L(t) ? !1 : e;
}
function T(t, e, n, i) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), r = q(t);
  let s = m(1);
  e && (i ? v(i) && (s = F(i)) : s = F(t));
  const c = ht(r, n, i) ? X(r) : m(0);
  let l = (o.left + c.x) / s.x, f = (o.top + c.y) / s.y, u = o.width / s.x, h = o.height / s.y;
  if (r) {
    const p = L(r), a = i && v(i) ? L(i) : i;
    let y = p, g = K(y);
    for (; g && i && a !== y; ) {
      const w = F(g), d = g.getBoundingClientRect(), x = R(g), C = d.left + (g.clientLeft + parseFloat(x.paddingLeft)) * w.x, B = d.top + (g.clientTop + parseFloat(x.paddingTop)) * w.y;
      l *= w.x, f *= w.y, u *= w.x, h *= w.y, l += C, f += B, y = L(g), g = K(y);
    }
  }
  return J({
    width: u,
    height: h,
    x: l,
    y: f
  });
}
function k(t, e) {
  const n = I(t).scrollLeft;
  return e ? e.left + n : T(O(t)).left + n;
}
function tt(t, e, n) {
  n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), o = i.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    k(t, i)
  )), r = i.top + e.scrollTop;
  return {
    x: o,
    y: r
  };
}
function at(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: i,
    strategy: o
  } = t;
  const r = o === "fixed", s = O(i), c = e ? $(e.floating) : !1;
  if (i === s || c && r)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = m(1);
  const u = m(0), h = b(i);
  if ((h || !h && !r) && ((S(i) !== "body" || _(s)) && (l = I(i)), b(i))) {
    const a = T(i);
    f = F(i), u.x = a.x + i.clientLeft, u.y = a.y + i.clientTop;
  }
  const p = s && !h && !r ? tt(s, l, !0) : m(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - l.scrollLeft * f.x + u.x + p.x,
    y: n.y * f.y - l.scrollTop * f.y + u.y + p.y
  };
}
function dt(t) {
  return Array.from(t.getClientRects());
}
function gt(t) {
  const e = O(t), n = I(t), i = t.ownerDocument.body, o = E(e.scrollWidth, e.clientWidth, i.scrollWidth, i.clientWidth), r = E(e.scrollHeight, e.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -n.scrollLeft + k(t);
  const c = -n.scrollTop;
  return R(i).direction === "rtl" && (s += E(e.clientWidth, i.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: c
  };
}
function pt(t, e) {
  const n = L(t), i = O(t), o = n.visualViewport;
  let r = i.clientWidth, s = i.clientHeight, c = 0, l = 0;
  if (o) {
    r = o.width, s = o.height;
    const f = Q();
    (!f || f && e === "fixed") && (c = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: c,
    y: l
  };
}
function wt(t, e) {
  const n = T(t, !0, e === "fixed"), i = n.top + t.clientTop, o = n.left + t.clientLeft, r = b(t) ? F(t) : m(1), s = t.clientWidth * r.x, c = t.clientHeight * r.y, l = o * r.x, f = i * r.y;
  return {
    width: s,
    height: c,
    x: l,
    y: f
  };
}
function j(t, e, n) {
  let i;
  if (e === "viewport")
    i = pt(t, n);
  else if (e === "document")
    i = gt(O(t));
  else if (v(e))
    i = wt(e, n);
  else {
    const o = X(t);
    i = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return J(i);
}
function et(t, e) {
  const n = W(t);
  return n === e || !v(n) || N(n) ? !1 : R(n).position === "fixed" || et(n, e);
}
function mt(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let i = M(t, [], !1).filter((c) => v(c) && S(c) !== "body"), o = null;
  const r = R(t).position === "fixed";
  let s = r ? W(t) : t;
  for (; v(s) && !N(s); ) {
    const c = R(s), l = Y(s);
    !l && c.position === "fixed" && (o = null), (r ? !l && !o : !l && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || _(s) && !l && et(t, s)) ? i = i.filter((u) => u !== s) : o = c, s = W(s);
  }
  return e.set(t, i), i;
}
function yt(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: i,
    strategy: o
  } = t;
  const s = [...n === "clippingAncestors" ? $(e) ? [] : mt(e, this._c) : [].concat(n), i], c = s[0], l = s.reduce((f, u) => {
    const h = j(e, u, o);
    return f.top = E(h.top, f.top), f.right = z(h.right, f.right), f.bottom = z(h.bottom, f.bottom), f.left = E(h.left, f.left), f;
  }, j(e, c, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function xt(t) {
  const {
    width: e,
    height: n
  } = Z(t);
  return {
    width: e,
    height: n
  };
}
function vt(t, e, n) {
  const i = b(e), o = O(e), r = n === "fixed", s = T(t, !0, r, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = m(0);
  if (i || !i && !r)
    if ((S(e) !== "body" || _(o)) && (c = I(e)), i) {
      const p = T(e, !0, r, e);
      l.x = p.x + e.clientLeft, l.y = p.y + e.clientTop;
    } else o && (l.x = k(o));
  const f = o && !i && !r ? tt(o, c) : m(0), u = s.left + c.scrollLeft - l.x - f.x, h = s.top + c.scrollTop - l.y - f.y;
  return {
    x: u,
    y: h,
    width: s.width,
    height: s.height
  };
}
function V(t) {
  return R(t).position === "static";
}
function G(t, e) {
  if (!b(t) || R(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return O(t) === n && (n = n.ownerDocument.body), n;
}
function nt(t, e) {
  const n = L(t);
  if ($(t))
    return n;
  if (!b(t)) {
    let o = W(t);
    for (; o && !N(o); ) {
      if (v(o) && !V(o))
        return o;
      o = W(o);
    }
    return n;
  }
  let i = G(t, e);
  for (; i && lt(i) && V(i); )
    i = G(i, e);
  return i && N(i) && V(i) && !Y(i) ? n : i || ft(t) || n;
}
const Rt = async function(t) {
  const e = this.getOffsetParent || nt, n = this.getDimensions, i = await n(t.floating);
  return {
    reference: vt(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function Ot(t) {
  return R(t).direction === "rtl";
}
const bt = {
  convertOffsetParentRelativeRectToViewportRelativeRect: at,
  getDocumentElement: O,
  getClippingRect: yt,
  getOffsetParent: nt,
  getElementRects: Rt,
  getClientRects: dt,
  getDimensions: xt,
  getScale: F,
  isElement: v,
  isRTL: Ot
};
function it(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function Ct(t, e) {
  let n = null, i;
  const o = O(t);
  function r() {
    var c;
    clearTimeout(i), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), r();
    const f = t.getBoundingClientRect(), {
      left: u,
      top: h,
      width: p,
      height: a
    } = f;
    if (c || e(), !p || !a)
      return;
    const y = A(h), g = A(o.clientWidth - (u + p)), w = A(o.clientHeight - (h + a)), d = A(u), C = {
      rootMargin: -y + "px " + -g + "px " + -w + "px " + -d + "px",
      threshold: E(0, z(1, l)) || 1
    };
    let B = !0;
    function P(U) {
      const D = U[0].intersectionRatio;
      if (D !== l) {
        if (!B)
          return s();
        D ? s(!1, D) : i = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !it(f, t.getBoundingClientRect()) && s(), B = !1;
    }
    try {
      n = new IntersectionObserver(P, {
        ...C,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(P, C);
    }
    n.observe(t);
  }
  return s(!0), r;
}
function Ft(t, e, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, f = q(t), u = o || r ? [...f ? M(f) : [], ...M(e)] : [];
  u.forEach((d) => {
    o && d.addEventListener("scroll", n, {
      passive: !0
    }), r && d.addEventListener("resize", n);
  });
  const h = f && c ? Ct(f, n) : null;
  let p = -1, a = null;
  s && (a = new ResizeObserver((d) => {
    let [x] = d;
    x && x.target === f && a && (a.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var C;
      (C = a) == null || C.observe(e);
    })), n();
  }), f && !l && a.observe(f), a.observe(e));
  let y, g = l ? T(t) : null;
  l && w();
  function w() {
    const d = T(t);
    g && !it(g, d) && n(), g = d, y = requestAnimationFrame(w);
  }
  return n(), () => {
    var d;
    u.forEach((x) => {
      o && x.removeEventListener("scroll", n), r && x.removeEventListener("resize", n);
    }), h == null || h(), (d = a) == null || d.disconnect(), a = null, l && cancelAnimationFrame(y);
  };
}
const Wt = ot, Bt = st, Dt = rt, At = (t, e, n) => {
  const i = /* @__PURE__ */ new Map(), o = {
    platform: bt,
    ...n
  }, r = {
    ...o.platform,
    _c: i
  };
  return ct(t, e, {
    ...o,
    platform: r
  });
};
export {
  Dt as arrow,
  Ft as autoUpdate,
  At as computePosition,
  Bt as flip,
  M as getOverflowAncestors,
  Wt as offset,
  bt as platform
};
