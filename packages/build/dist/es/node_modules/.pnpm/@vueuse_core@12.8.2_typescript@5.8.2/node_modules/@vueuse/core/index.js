import { tryOnScopeDispose as B, toArray as S, watchImmediate as P, isClient as L, isObject as _, useTimeoutFn as I, tryOnMounted as q, createSingletonPromise as H } from "../../../../@vueuse_shared@12.8.2_typescript@5.8.2/node_modules/@vueuse/shared/index.js";
import { getLifeCycleTarget as X } from "../../../../@vueuse_shared@12.8.2_typescript@5.8.2/node_modules/@vueuse/shared/index.js";
import { computed as x, toValue as y, watch as T, shallowRef as b, getCurrentInstance as V, onMounted as $, unref as j, toRaw as F } from "vue";
const R = L ? window : void 0, W = L ? window.navigator : void 0;
function g(n) {
  var o;
  const l = y(n);
  return (o = l == null ? void 0 : l.$el) != null ? o : l;
}
function A(...n) {
  const o = [], l = () => {
    o.forEach((t) => t()), o.length = 0;
  }, p = (t, u, i, s) => (t.addEventListener(u, i, s), () => t.removeEventListener(u, i, s)), d = x(() => {
    const t = S(y(n[0])).filter((u) => u != null);
    return t.every((u) => typeof u != "string") ? t : void 0;
  }), c = P(
    () => {
      var t, u;
      return [
        (u = (t = d.value) == null ? void 0 : t.map((i) => g(i))) != null ? u : [R].filter((i) => i != null),
        S(y(d.value ? n[1] : n[0])),
        S(j(d.value ? n[2] : n[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        y(d.value ? n[3] : n[2])
      ];
    },
    ([t, u, i, s]) => {
      if (l(), !(t != null && t.length) || !(u != null && u.length) || !(i != null && i.length))
        return;
      const e = _(s) ? { ...s } : s;
      o.push(
        ...t.flatMap(
          (v) => u.flatMap(
            (m) => i.map((h) => p(v, m, h, e))
          )
        )
      );
    },
    { flush: "post" }
  ), r = () => {
    c(), l();
  };
  return B(l), r;
}
function G() {
  const n = b(!1), o = V();
  return o && $(() => {
    n.value = !0;
  }, o), n;
}
function E(n) {
  const o = G();
  return x(() => (o.value, !!n()));
}
function O(n, o = {}) {
  const {
    controls: l = !1,
    navigator: p = W
  } = o, d = E(() => p && "permissions" in p), c = b(), r = typeof n == "string" ? { name: n } : n, t = b(), u = () => {
    var s, e;
    t.value = (e = (s = c.value) == null ? void 0 : s.state) != null ? e : "prompt";
  };
  A(c, "change", u, { passive: !0 });
  const i = H(async () => {
    if (d.value) {
      if (!c.value)
        try {
          c.value = await p.permissions.query(r);
        } catch {
          c.value = void 0;
        } finally {
          u();
        }
      if (l)
        return F(c.value);
    }
  });
  return i(), l ? {
    state: t,
    isSupported: d,
    query: i
  } : t;
}
function D(n = {}) {
  const {
    navigator: o = W,
    read: l = !1,
    source: p,
    copiedDuring: d = 1500,
    legacy: c = !1
  } = n, r = E(() => o && "clipboard" in o), t = O("clipboard-read"), u = O("clipboard-write"), i = x(() => r.value || c), s = b(""), e = b(!1), v = I(() => e.value = !1, d, { immediate: !1 });
  async function m() {
    let a = !(r.value && M(t.value));
    if (!a)
      try {
        s.value = await o.clipboard.readText();
      } catch {
        a = !0;
      }
    a && (s.value = z());
  }
  i.value && l && A(["copy", "cut"], m, { passive: !0 });
  async function h(a = y(p)) {
    if (i.value && a != null) {
      let f = !(r.value && M(u.value));
      if (!f)
        try {
          await o.clipboard.writeText(a);
        } catch {
          f = !0;
        }
      f && w(a), s.value = a, e.value = !0, v.start();
    }
  }
  function w(a) {
    const f = document.createElement("textarea");
    f.value = a ?? "", f.style.position = "absolute", f.style.opacity = "0", document.body.appendChild(f), f.select(), document.execCommand("copy"), f.remove();
  }
  function z() {
    var a, f, C;
    return (C = (f = (a = document == null ? void 0 : document.getSelection) == null ? void 0 : a.call(document)) == null ? void 0 : f.toString()) != null ? C : "";
  }
  function M(a) {
    return a === "granted" || a === "prompt";
  }
  return {
    isSupported: i,
    text: s,
    copied: e,
    copy: h
  };
}
function N(n, o, l = {}) {
  const { window: p = R, ...d } = l;
  let c;
  const r = E(() => p && "ResizeObserver" in p), t = () => {
    c && (c.disconnect(), c = void 0);
  }, u = x(() => {
    const e = y(n);
    return Array.isArray(e) ? e.map((v) => g(v)) : [g(e)];
  }), i = T(
    u,
    (e) => {
      if (t(), r.value && p) {
        c = new ResizeObserver(o);
        for (const v of e)
          v && c.observe(v, d);
      }
    },
    { immediate: !0, flush: "post" }
  ), s = () => {
    t(), i();
  };
  return B(s), {
    isSupported: r,
    stop: s
  };
}
function J(n, o = { width: 0, height: 0 }, l = {}) {
  const { window: p = R, box: d = "content-box" } = l, c = x(() => {
    var e, v;
    return (v = (e = g(n)) == null ? void 0 : e.namespaceURI) == null ? void 0 : v.includes("svg");
  }), r = b(o.width), t = b(o.height), { stop: u } = N(
    n,
    ([e]) => {
      const v = d === "border-box" ? e.borderBoxSize : d === "content-box" ? e.contentBoxSize : e.devicePixelContentBoxSize;
      if (p && c.value) {
        const m = g(n);
        if (m) {
          const h = m.getBoundingClientRect();
          r.value = h.width, t.value = h.height;
        }
      } else if (v) {
        const m = S(v);
        r.value = m.reduce((h, { inlineSize: w }) => h + w, 0), t.value = m.reduce((h, { blockSize: w }) => h + w, 0);
      } else
        r.value = e.contentRect.width, t.value = e.contentRect.height;
    },
    l
  );
  q(() => {
    const e = g(n);
    e && (r.value = "offsetWidth" in e ? e.offsetWidth : o.width, t.value = "offsetHeight" in e ? e.offsetHeight : o.height);
  });
  const i = T(
    () => g(n),
    (e) => {
      r.value = e ? o.width : 0, t.value = e ? o.height : 0;
    }
  );
  function s() {
    u(), i();
  }
  return {
    width: r,
    height: t,
    stop: s
  };
}
export {
  H as createSingletonPromise,
  W as defaultNavigator,
  R as defaultWindow,
  X as getLifeCycleTarget,
  L as isClient,
  _ as isObject,
  S as toArray,
  q as tryOnMounted,
  B as tryOnScopeDispose,
  g as unrefElement,
  D as useClipboard,
  J as useElementSize,
  A as useEventListener,
  G as useMounted,
  O as usePermission,
  N as useResizeObserver,
  E as useSupported,
  I as useTimeoutFn,
  P as watchImmediate
};
