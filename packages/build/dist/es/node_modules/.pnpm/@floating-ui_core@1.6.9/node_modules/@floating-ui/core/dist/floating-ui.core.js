import { evaluate as $, getSide as B, getSideAxis as M, getOppositePlacement as G, getExpandedPlacements as J, getOppositeAxisPlacements as K, getAlignmentSides as N, getAlignment as Y, getPaddingObject as H, getAlignmentAxis as I, clamp as Q, rectToClientRect as X, getAxisLength as W, min as _ } from "../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
function z(o, s, f) {
  let {
    reference: n,
    floating: l
  } = o;
  const e = M(s), a = I(s), i = W(a), m = B(s), g = e === "y", u = n.x + n.width / 2 - l.width / 2, c = n.y + n.height / 2 - l.height / 2, d = n[i] / 2 - l[i] / 2;
  let t;
  switch (m) {
    case "top":
      t = {
        x: u,
        y: n.y - l.height
      };
      break;
    case "bottom":
      t = {
        x: u,
        y: n.y + n.height
      };
      break;
    case "right":
      t = {
        x: n.x + n.width,
        y: c
      };
      break;
    case "left":
      t = {
        x: n.x - l.width,
        y: c
      };
      break;
    default:
      t = {
        x: n.x,
        y: n.y
      };
  }
  switch (Y(s)) {
    case "start":
      t[a] -= d * (f && g ? -1 : 1);
      break;
    case "end":
      t[a] += d * (f && g ? -1 : 1);
      break;
  }
  return t;
}
const te = async (o, s, f) => {
  const {
    placement: n = "bottom",
    strategy: l = "absolute",
    middleware: e = [],
    platform: a
  } = f, i = e.filter(Boolean), m = await (a.isRTL == null ? void 0 : a.isRTL(s));
  let g = await a.getElementRects({
    reference: o,
    floating: s,
    strategy: l
  }), {
    x: u,
    y: c
  } = z(g, n, m), d = n, t = {}, r = 0;
  for (let p = 0; p < i.length; p++) {
    const {
      name: v,
      fn: A
    } = i[p], {
      x: P,
      y,
      data: h,
      reset: x
    } = await A({
      x: u,
      y: c,
      initialPlacement: n,
      placement: d,
      strategy: l,
      middlewareData: t,
      rects: g,
      platform: a,
      elements: {
        reference: o,
        floating: s
      }
    });
    u = P ?? u, c = y ?? c, t = {
      ...t,
      [v]: {
        ...t[v],
        ...h
      }
    }, x && r <= 50 && (r++, typeof x == "object" && (x.placement && (d = x.placement), x.rects && (g = x.rects === !0 ? await a.getElementRects({
      reference: o,
      floating: s,
      strategy: l
    }) : x.rects), {
      x: u,
      y: c
    } = z(g, d, m)), p = -1);
  }
  return {
    x: u,
    y: c,
    placement: d,
    strategy: l,
    middlewareData: t
  };
};
async function U(o, s) {
  var f;
  s === void 0 && (s = {});
  const {
    x: n,
    y: l,
    platform: e,
    rects: a,
    elements: i,
    strategy: m
  } = o, {
    boundary: g = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: c = "floating",
    altBoundary: d = !1,
    padding: t = 0
  } = $(s, o), r = H(t), v = i[d ? c === "floating" ? "reference" : "floating" : c], A = X(await e.getClippingRect({
    element: (f = await (e.isElement == null ? void 0 : e.isElement(v))) == null || f ? v : v.contextElement || await (e.getDocumentElement == null ? void 0 : e.getDocumentElement(i.floating)),
    boundary: g,
    rootBoundary: u,
    strategy: m
  })), P = c === "floating" ? {
    x: n,
    y: l,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, y = await (e.getOffsetParent == null ? void 0 : e.getOffsetParent(i.floating)), h = await (e.isElement == null ? void 0 : e.isElement(y)) ? await (e.getScale == null ? void 0 : e.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = X(e.convertOffsetParentRelativeRectToViewportRelativeRect ? await e.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: P,
    offsetParent: y,
    strategy: m
  }) : P);
  return {
    top: (A.top - x.top + r.top) / h.y,
    bottom: (x.bottom - A.bottom + r.bottom) / h.y,
    left: (A.left - x.left + r.left) / h.x,
    right: (x.right - A.right + r.right) / h.x
  };
}
const ne = (o) => ({
  name: "arrow",
  options: o,
  async fn(s) {
    const {
      x: f,
      y: n,
      placement: l,
      rects: e,
      platform: a,
      elements: i,
      middlewareData: m
    } = s, {
      element: g,
      padding: u = 0
    } = $(o, s) || {};
    if (g == null)
      return {};
    const c = H(u), d = {
      x: f,
      y: n
    }, t = I(l), r = W(t), p = await a.getDimensions(g), v = t === "y", A = v ? "top" : "left", P = v ? "bottom" : "right", y = v ? "clientHeight" : "clientWidth", h = e.reference[r] + e.reference[t] - d[t] - e.floating[r], x = d[t] - e.reference[t], T = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(g));
    let E = T ? T[y] : 0;
    (!E || !await (a.isElement == null ? void 0 : a.isElement(T))) && (E = i.floating[y] || e.floating[r]);
    const V = h / 2 - x / 2, C = E / 2 - p[r] / 2 - 1, O = _(c[A], C), F = _(c[P], C), S = O, j = E - p[r] - F, w = E / 2 - p[r] / 2 + V, L = Q(S, w, j), R = !m.arrow && Y(l) != null && w !== L && e.reference[r] / 2 - (w < S ? O : F) - p[r] / 2 < 0, b = R ? w < S ? w - S : w - j : 0;
    return {
      [t]: d[t] + b,
      data: {
        [t]: L,
        centerOffset: w - L - b,
        ...R && {
          alignmentOffset: b
        }
      },
      reset: R
    };
  }
}), ie = function(o) {
  return o === void 0 && (o = {}), {
    name: "flip",
    options: o,
    async fn(s) {
      var f, n;
      const {
        placement: l,
        middlewareData: e,
        rects: a,
        initialPlacement: i,
        platform: m,
        elements: g
      } = s, {
        mainAxis: u = !0,
        crossAxis: c = !0,
        fallbackPlacements: d,
        fallbackStrategy: t = "bestFit",
        fallbackAxisSideDirection: r = "none",
        flipAlignment: p = !0,
        ...v
      } = $(o, s);
      if ((f = e.arrow) != null && f.alignmentOffset)
        return {};
      const A = B(l), P = M(i), y = B(i) === i, h = await (m.isRTL == null ? void 0 : m.isRTL(g.floating)), x = d || (y || !p ? [G(i)] : J(i)), T = r !== "none";
      !d && T && x.push(...K(i, p, r, h));
      const E = [i, ...x], V = await U(s, v), C = [];
      let O = ((n = e.flip) == null ? void 0 : n.overflows) || [];
      if (u && C.push(V[A]), c) {
        const w = N(l, a, h);
        C.push(V[w[0]], V[w[1]]);
      }
      if (O = [...O, {
        placement: l,
        overflows: C
      }], !C.every((w) => w <= 0)) {
        var F, S;
        const w = (((F = e.flip) == null ? void 0 : F.index) || 0) + 1, L = E[w];
        if (L)
          return {
            data: {
              index: w,
              overflows: O
            },
            reset: {
              placement: L
            }
          };
        let R = (S = O.filter((b) => b.overflows[0] <= 0).sort((b, k) => b.overflows[1] - k.overflows[1])[0]) == null ? void 0 : S.placement;
        if (!R)
          switch (t) {
            case "bestFit": {
              var j;
              const b = (j = O.filter((k) => {
                if (T) {
                  const D = M(k.placement);
                  return D === P || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  D === "y";
                }
                return !0;
              }).map((k) => [k.placement, k.overflows.filter((D) => D > 0).reduce((D, q) => D + q, 0)]).sort((k, D) => k[1] - D[1])[0]) == null ? void 0 : j[0];
              b && (R = b);
              break;
            }
            case "initialPlacement":
              R = i;
              break;
          }
        if (l !== R)
          return {
            reset: {
              placement: R
            }
          };
      }
      return {};
    }
  };
};
async function Z(o, s) {
  const {
    placement: f,
    platform: n,
    elements: l
  } = o, e = await (n.isRTL == null ? void 0 : n.isRTL(l.floating)), a = B(f), i = Y(f), m = M(f) === "y", g = ["left", "top"].includes(a) ? -1 : 1, u = e && m ? -1 : 1, c = $(s, o);
  let {
    mainAxis: d,
    crossAxis: t,
    alignmentAxis: r
  } = typeof c == "number" ? {
    mainAxis: c,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: c.mainAxis || 0,
    crossAxis: c.crossAxis || 0,
    alignmentAxis: c.alignmentAxis
  };
  return i && typeof r == "number" && (t = i === "end" ? r * -1 : r), m ? {
    x: t * u,
    y: d * g
  } : {
    x: d * g,
    y: t * u
  };
}
const ae = function(o) {
  return o === void 0 && (o = 0), {
    name: "offset",
    options: o,
    async fn(s) {
      var f, n;
      const {
        x: l,
        y: e,
        placement: a,
        middlewareData: i
      } = s, m = await Z(s, o);
      return a === ((f = i.offset) == null ? void 0 : f.placement) && (n = i.arrow) != null && n.alignmentOffset ? {} : {
        x: l + m.x,
        y: e + m.y,
        data: {
          ...m,
          placement: a
        }
      };
    }
  };
};
export {
  ne as arrow,
  te as computePosition,
  U as detectOverflow,
  ie as flip,
  ae as offset,
  X as rectToClientRect
};
