"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const n=require("../../../../../@floating-ui_utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.js");function B(o,s,m){let{reference:i,floating:c}=o;const e=n.getSideAxis(s),l=n.getAlignmentAxis(s),a=n.getAxisLength(l),d=n.getSide(s),u=e==="y",x=i.x+i.width/2-c.width/2,r=i.y+i.height/2-c.height/2,g=i[a]/2-c[a]/2;let t;switch(d){case"top":t={x,y:i.y-c.height};break;case"bottom":t={x,y:i.y+i.height};break;case"right":t={x:i.x+i.width,y:r};break;case"left":t={x:i.x-c.width,y:r};break;default:t={x:i.x,y:i.y}}switch(n.getAlignment(s)){case"start":t[l]-=g*(m&&u?-1:1);break;case"end":t[l]+=g*(m&&u?-1:1);break}return t}const _=async(o,s,m)=>{const{placement:i="bottom",strategy:c="absolute",middleware:e=[],platform:l}=m,a=e.filter(Boolean),d=await(l.isRTL==null?void 0:l.isRTL(s));let u=await l.getElementRects({reference:o,floating:s,strategy:c}),{x,y:r}=B(u,i,d),g=i,t={},f=0;for(let v=0;v<a.length;v++){const{name:y,fn:b}=a[v],{x:R,y:A,data:h,reset:w}=await b({x,y:r,initialPlacement:i,placement:g,strategy:c,middlewareData:t,rects:u,platform:l,elements:{reference:o,floating:s}});x=R??x,r=A??r,t={...t,[y]:{...t[y],...h}},w&&f<=50&&(f++,typeof w=="object"&&(w.placement&&(g=w.placement),w.rects&&(u=w.rects===!0?await l.getElementRects({reference:o,floating:s,strategy:c}):w.rects),{x,y:r}=B(u,g,d)),v=-1)}return{x,y:r,placement:g,strategy:c,middlewareData:t}};async function $(o,s){var m;s===void 0&&(s={});const{x:i,y:c,platform:e,rects:l,elements:a,strategy:d}=o,{boundary:u="clippingAncestors",rootBoundary:x="viewport",elementContext:r="floating",altBoundary:g=!1,padding:t=0}=n.evaluate(s,o),f=n.getPaddingObject(t),y=a[g?r==="floating"?"reference":"floating":r],b=n.rectToClientRect(await e.getClippingRect({element:(m=await(e.isElement==null?void 0:e.isElement(y)))==null||m?y:y.contextElement||await(e.getDocumentElement==null?void 0:e.getDocumentElement(a.floating)),boundary:u,rootBoundary:x,strategy:d})),R=r==="floating"?{x:i,y:c,width:l.floating.width,height:l.floating.height}:l.reference,A=await(e.getOffsetParent==null?void 0:e.getOffsetParent(a.floating)),h=await(e.isElement==null?void 0:e.isElement(A))?await(e.getScale==null?void 0:e.getScale(A))||{x:1,y:1}:{x:1,y:1},w=n.rectToClientRect(e.convertOffsetParentRelativeRectToViewportRelativeRect?await e.convertOffsetParentRelativeRectToViewportRelativeRect({elements:a,rect:R,offsetParent:A,strategy:d}):R);return{top:(b.top-w.top+f.top)/h.y,bottom:(w.bottom-b.bottom+f.bottom)/h.y,left:(b.left-w.left+f.left)/h.x,right:(w.right-b.right+f.right)/h.x}}const X=o=>({name:"arrow",options:o,async fn(s){const{x:m,y:i,placement:c,rects:e,platform:l,elements:a,middlewareData:d}=s,{element:u,padding:x=0}=n.evaluate(o,s)||{};if(u==null)return{};const r=n.getPaddingObject(x),g={x:m,y:i},t=n.getAlignmentAxis(c),f=n.getAxisLength(t),v=await l.getDimensions(u),y=t==="y",b=y?"top":"left",R=y?"bottom":"right",A=y?"clientHeight":"clientWidth",h=e.reference[f]+e.reference[t]-g[t]-e.floating[f],w=g[t]-e.reference[t],L=await(l.getOffsetParent==null?void 0:l.getOffsetParent(u));let T=L?L[A]:0;(!T||!await(l.isElement==null?void 0:l.isElement(L)))&&(T=a.floating[A]||e.floating[f]);const V=h/2-w/2,D=T/2-v[f]/2-1,S=n.min(r[b],D),F=n.min(r[R],D),E=S,M=T-v[f]-F,p=T/2-v[f]/2+V,j=n.clamp(E,p,M),O=!d.arrow&&n.getAlignment(c)!=null&&p!==j&&e.reference[f]/2-(p<E?S:F)-v[f]/2<0,P=O?p<E?p-E:p-M:0;return{[t]:g[t]+P,data:{[t]:j,centerOffset:p-j-P,...O&&{alignmentOffset:P}},reset:O}}}),q=function(o){return o===void 0&&(o={}),{name:"flip",options:o,async fn(s){var m,i;const{placement:c,middlewareData:e,rects:l,initialPlacement:a,platform:d,elements:u}=s,{mainAxis:x=!0,crossAxis:r=!0,fallbackPlacements:g,fallbackStrategy:t="bestFit",fallbackAxisSideDirection:f="none",flipAlignment:v=!0,...y}=n.evaluate(o,s);if((m=e.arrow)!=null&&m.alignmentOffset)return{};const b=n.getSide(c),R=n.getSideAxis(a),A=n.getSide(a)===a,h=await(d.isRTL==null?void 0:d.isRTL(u.floating)),w=g||(A||!v?[n.getOppositePlacement(a)]:n.getExpandedPlacements(a)),L=f!=="none";!g&&L&&w.push(...n.getOppositeAxisPlacements(a,v,f,h));const T=[a,...w],V=await $(s,y),D=[];let S=((i=e.flip)==null?void 0:i.overflows)||[];if(x&&D.push(V[b]),r){const p=n.getAlignmentSides(c,l,h);D.push(V[p[0]],V[p[1]])}if(S=[...S,{placement:c,overflows:D}],!D.every(p=>p<=0)){var F,E;const p=(((F=e.flip)==null?void 0:F.index)||0)+1,j=T[p];if(j)return{data:{index:p,overflows:S},reset:{placement:j}};let O=(E=S.filter(P=>P.overflows[0]<=0).sort((P,k)=>P.overflows[1]-k.overflows[1])[0])==null?void 0:E.placement;if(!O)switch(t){case"bestFit":{var M;const P=(M=S.filter(k=>{if(L){const C=n.getSideAxis(k.placement);return C===R||C==="y"}return!0}).map(k=>[k.placement,k.overflows.filter(C=>C>0).reduce((C,Y)=>C+Y,0)]).sort((k,C)=>k[1]-C[1])[0])==null?void 0:M[0];P&&(O=P);break}case"initialPlacement":O=a;break}if(c!==O)return{reset:{placement:O}}}return{}}}};async function z(o,s){const{placement:m,platform:i,elements:c}=o,e=await(i.isRTL==null?void 0:i.isRTL(c.floating)),l=n.getSide(m),a=n.getAlignment(m),d=n.getSideAxis(m)==="y",u=["left","top"].includes(l)?-1:1,x=e&&d?-1:1,r=n.evaluate(s,o);let{mainAxis:g,crossAxis:t,alignmentAxis:f}=typeof r=="number"?{mainAxis:r,crossAxis:0,alignmentAxis:null}:{mainAxis:r.mainAxis||0,crossAxis:r.crossAxis||0,alignmentAxis:r.alignmentAxis};return a&&typeof f=="number"&&(t=a==="end"?f*-1:f),d?{x:t*x,y:g*u}:{x:g*u,y:t*x}}const H=function(o){return o===void 0&&(o=0),{name:"offset",options:o,async fn(s){var m,i;const{x:c,y:e,placement:l,middlewareData:a}=s,d=await z(s,o);return l===((m=a.offset)==null?void 0:m.placement)&&(i=a.arrow)!=null&&i.alignmentOffset?{}:{x:c+d.x,y:e+d.y,data:{...d,placement:l}}}}};exports.rectToClientRect=n.rectToClientRect;exports.arrow=X;exports.computePosition=_;exports.detectOverflow=$;exports.flip=q;exports.offset=H;
